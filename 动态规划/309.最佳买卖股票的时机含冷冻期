1.题目描述:https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

对于力扣平台上的股票类型的题目：
  121. 买卖股票的最佳时机
  122. 买卖股票的最佳时机 II
  123. 买卖股票的最佳时机 III
  188. 买卖股票的最佳时机 IV
  （本题）309. 最佳买卖股票时机含冷冻期
  714. 买卖股票的最佳时机含手续费
  剑指 Offer 63. 股票的最大利润


2.思路：动态规划（实在没思路，参考的官方回答）
  1）dp[i] 表示第i天「结束后」的最大收益；根据题目描述由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制,我们一共可以分为以下3种状态
    1.1）第i天手里拥有一只股票，目前为止最大收益记为dp[i][0]；
    1.2）第i天手里没有一只股票，且处于冷冻期（即第i-1天结束卖出了股票），目前为止最大收益记为dp[i][1];
    1.3）第i天手里既不拥有一只股票也不处于冷冻期，，目前为止最大收益记为dp[i][2];
    注意:这里的「处于冷冻期」指的是在第 i 天「结束之后的状态」。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。（第i天卖出股票，
         那么第i天结束后就是冷冻期，第i+1天就不能买入）
  2)思考转移方程：
    2.1）对于dp[i][0]，表明目前手里有一只股票，那么这只股票可以是在第 i-1 天就已经拥有的，即dp[i][0] = dp[i-1][0]；也可以是在第i天买入的，这表明 i-1天 处于
         第 3 种即手里不拥有股票也不处于冷冻期，即dp[i] = dp[i-1][2] - prices[i];
         综上dp[i][0] = max( dp[i-1][0], dp[i-1][2] - prices[i])
    2.2）对于dp[i][1]，表明今天结束后处于冷冻期，也就是今天卖出了股票，那么前一天必定拥有一只股票，即dp[i][1] = dp[i-1][0] + price[i]
    2.3）对于dp[i][2]，我们在第 i 天结束之后不持有任何股票并且不处于冷冻期，说明当天没有进行任何操作，
         即第 i-1 天时不持有任何股票：如果处于冷冻期，对应的状态为 dp[i−1][1]；如果不处于冷冻期，对应的状态为 dp[i−1][2]。
         因此状态转移方程为：dp[i][2] = max( dp[i−1][1], dp[i−1][2])
         
  3）如果一共有 n 天，那么最终的答案即为：max(dp[n-1][0], dp[n-1][1], dp[n-1][2])，但是考虑到最后一天（第 n-1 天）结束之后，手上仍然持有股票，那么显然是没有任何意义的。
      因此更加精确地，最终的答案实际上是 f[n−1][1] 和 f[n−1][2] 中的较大值，即：max(dp[n-1][1], dp[n-1][2])
  4）考虑边界条件：我们可以将第 0 天的情况作为动态规划中的边界条件：
        dp[0][0] = −prices[0]
        dp[0][1] = 0
        dp[0][2] = 0
     在第 0 天时，如果持有股票，那么只能是在第 0 天买入的，对应负收益 −prices[0]；如果不持有股票，那么收益为零。注意到第 0 天实际上是不存在处于冷冻期的情况的，
     但我们仍然可以将对应的状态 f[0][1]f[0][1] 置为零.

3.代码1:
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if(len < 2) return 0;
        int[][] dp = new int[len][3];
        dp[0][0] = 0 - prices[0];
        for(int i = 1; i < len; i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][2] - prices[i]);
            dp[i][1] = dp[i-1][0] + prices[i];
            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]); 
        }
        return Math.max(dp[len-1][1],dp[len-1][2]);
    }

4.对代码1进行优化，当前状态只与前一天三个状态有关，保留这个三个状态即可
   public int maxProfit(int[] prices) {
        if (prices.length == 0) {
            return 0;
        }

        int n = prices.length;
        int f0 = -prices[0];
        int f1 = 0;
        int f2 = 0;
        for (int i = 1; i < n; ++i) {
            int newf0 = Math.max(f0, f2 - prices[i]);
            int newf1 = f0 + prices[i];
            int newf2 = Math.max(f1, f2);
            f0 = newf0;
            f1 = newf1;
            f2 = newf2;
        }

        return Math.max(f1, f2);
    }


   
         
         
