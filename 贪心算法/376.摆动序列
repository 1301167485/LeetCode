1.题目描述：https://leetcode-cn.com/problems/wiggle-subsequence/
  如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

  例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

  给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

  示例 1:

  输入: [1,7,4,9,2,5]
  输出: 6 
  解释: 整个序列均为摆动序列。
  示例 2:

  输入: [1,17,5,10,13,15,10,5,16,8]
  输出: 7
  解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
  示例 3:

  输入: [1,2,3,4,5,6,7,8,9]
  输出: 2

2.思路:
  看完题目后思考：
    1）题目的意思是当前元素nums[i]，nums[i-1]，nums[i-2]，这三个元素的差值必须不同，如果nums[i] 大于 nums[i-1]，那么nums[i-1]要 小于 nums[i-2]才算一个摆动序列
    2）说白了就是数字序列两个相邻的数字的差值，要一正一负。
    3）还有要注意，这里的子序列并不是说一定要连续的子序列并，而是说在选择数字加入摆动序列时，可以跳跃选择，如题目中的示例2，选择了1,17,10,13,10,16,8作为其子序列
  实现过程：
    1）设当前元素索引为i
    2）如果当前元素 大于 前一个元素，并且前一个元素 小于 前前一个元素，即 nums[i] > nums[i-1] && nums[i-1] < nums[i-2]，那么令最大子序的个数加1
    3）如果当前元素 小于 前一个元素，并且前一个元素 大于 前前一个元素，即 nums[i] < nums[i-1] && nums[i-1] > nums[i-2]，那么令最大子序的个数加1
    4）如果当前元素 大于 前一个元素，并且前一个元素 大于 前前一个元素，即 nums[i] > nums[i-1] && nums[i-1] > nums[i-2]，表明索引为i-2,i-1,i三个元素递增，不符合要求
    5）如果当前元素 小于 前一个元素，并且前一个元素 小于 前前一个元素，即 nums[i] < nums[i-1] && nums[i-1] < nums[i-2]，表明索引为i-2,i-1,i三个元素递减，不符合要求
    以上是大体思路：接下来看边界条件
    1）如果nums[i] = nums[i-1]呢？不符合上述任何一个条件，所以我们可以先判断nums[i] == nums[i-1]，相等则令i++，不相等则执行上述判断
    2）我们可以设定一个Boolean flagPre来表示前一个元素与前前一个元素的大小关系，flagPre = true表明nums[i-1] > nums[i-2]，反之表示nums[i-1] < nums[i-2]
    3）每次遍历一个元素以后，都要更新flagPre，因为要访问下一个元素了（即i指向下一个元素），那么flagPre也要移动一位。
    4）接下来考虑，序列中第一个数字一定复合规范，会成为摇摆序列中第一个数，那么第二个数如何判断？这个时候并没有flagPre，因为当i = 1时，并没有nums[i-2]这个元素，索引越界；
    我们不妨将flagPre 设置为int型，一共三个状态0,1,2；0表示之前的false：nums[i-1] < nums[i-2]；1表示之前的true：nums[i-1] > nums[i-2]；2表示当前为当前为第二个元素，此时程序
    不需要考虑 nums[i-1] 与 nums[i-2]的大小关系，只需要考虑nums[i] 与 nums[i-1]的大小关系。
    
 3.代码如下：观赏性一般，但是思路非常清晰且效率高（时间复杂度100，空间复杂度95，真的牛逼）
        public int wiggleMaxLength(int[] nums) {
        int len = nums.length;
        if(len <= 1) return len;
        int flagPre = 2;  // 初始化为
        int i = 1;
        // 只有一个数的时候一定是摇摆序列，从第二个数开始判别
        int max = 1;
        while(i < len){
            // 当前元素与前一个元素是否相等
            if(nums[i] != nums[i-1]){
                if(flagPre == 2){
                   max++;
                   flagPre = nums[i]-nums[i-1] > 0 ? 1 : 0;
                   i++; 
                }
                // 当前元素大于前一个元素，且前一个元素小于前前一个元素，符合要求
                if(nums[i] > nums[i-1] && flagPre == 0){
                    max++;
                    flagPre = 1;   //更新flagPre
                    i++;
                }
                //  当前元素小于前一个元素，且前一个元素大于前前一个元素，符合要求
                else if(nums[i] < nums[i-1] && flagPre == 1){
                    max++;
                    flagPre = 0;  //更新flagPre
                    i++;
                }
                // 当前元素大于前一个元素，且前一个元素大于前前一个元素，不符合要求
                else if(nums[i] > nums[i-1] && flagPre == 1){
                    i++;
                    flagPre = 1;  //更新flagPre
                }
                 // 当前元素小于前一个元素，且前一个元素小于前前一个元素，不符合要求
                else if(nums[i] < nums[i-1] && flagPre == 0){
                    i++;
                    flagPre = 0;  //更新flagPre
                }
                
            }else{
                i++;
            }
        }
        return max;
    }
    
    
    
    
    
    
    
    
    
    
