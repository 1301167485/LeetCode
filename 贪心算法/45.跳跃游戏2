1.题目描述:https://leetcode-cn.com/problems/jump-game-ii/
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
    

2.思路：
  注意：题目已经确定一定能跳到最后一个。
  模拟过程如下:下标依次为0，1，2，3，4，5，6；所对应的跳跃步数依次为2，3，1，4，2，3，
  1）从第一步开始跳，设即可以从下标0跳到下标2处；
  2）在下标0到下标2的过程中，第二步选择下标1的时候跳的最多，可以跳到4，超过了我们在1）中的下标2处
  3）所以选择第一步跳到下标为1处，
  4）在2）中刚刚我们遍历了下标为0-2能跳到的最远处，现在我们要遍历2-4我们能跳到的最远处
  5）为什么是遍历下标2-4呢？因为我们第一步跳到的最大范围是2，在这个范围内第二步的最大范围是4；换句话说，我们第一步最大能跳到0-2这个范围，那么在0-2范围内我们第二步能达到的最远距离是4，
     所以接下来遍历2-4（因为0-2已经遍历了），看看2-4之间最大能跳到的范围是多少，依次类推
  6）总结如下：
     （1）从下标0开始遍历元素，直到遍历完结束
     （2）当前下标下所能达到的最远记录记为end
     （3）遍历当前下标到end之间的元素，找出其中跳的最远的下标为max
     （4）步数+1，表明跳了一步，
     （5）从end遍历到max，找到其中能到达的最远距离，更新为max
    注意：在遍历数组时，我们不访问最后一个元素，这是因为:
            1）在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。
            2）如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。
            
3.代码：
    public int jump(int[] nums) {
          int len = nums.length;
          int max = 0; // 在当前位置到最远位置之间的元素，所能达到的最远距离
          int end = 0; // 当前最远能到达的距离
          int res = 0;
          // 遍历元素，不需要遍历最后一个
          for(int i = 0; i < len-1; i++){
              max = max > nums[i] + i ? max : nums[i] + i;
              if(i == end){
                  end = max;
                  res++;

              }
          }
          return res;
      }
